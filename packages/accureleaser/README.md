# 「精确类型」配套开发流程管理工具

[「精确类型」代码仓库](https://github.com/accurtype/accurtype)是一个 TypeScript 类型工具库。

这个工具库使用一套独特的开发流程，可以概括性地称为**以功能为中心的迭代速度很快的开发**。
我也不知道简称什么，就暂时简称功能快速开发吧。

本工具就是功能快速开发的一个实现工具。

## 功能快速开发中的基本概念

### 开发版本

开发过程由功能进行细分，不同功能在不同的 Git 分支上开发，产生不同的开发版本。

开发分支的命名格式类似 `dev-<feature>` 。

开发版本带 `dev-<feature>` 标签，版本号形如 `<x>.<y>.<z>-dev.<featrue>.<milestone>.<number>` 。
其中：

- `<x>.<y>.<z>` 表示作为此功能开发基础的非开发版本的版本号；
- `<featrue>` 表示功能的名字，遵循驼峰命名，比如 `compare` 、 `tailRecursion` 等；
- `<milestone>` 表示目前的开发阶段，比如 `alpha` 、 `beta` 、 `release` 等；
- `<number>` 表示在当前开发阶段迭代的次数。

比如 `1.0.3-dev.compare.beta.3` 表示是一个在 `1.0.3` 这个正式版本的基础上，专注于 `compare` 这项功能，到达 `beta` 这个开发阶段后，又递增了 `3` 次的开发版本。

- 如果又加了一些功能，这个版本号再递增一次就是 `1.0.3-dev.compare.beta.4` ；
- 如果达到下一个开发阶段了，就变成 `1.0.3-dev.compare.release.0` ；
- 如果开发中 `1.0.3` 修复了一个 bug ，变成了 `1.0.4` 版本。
  那么采用这个新版本来继续开发 `compare` 功能的开发版本就是 `1.0.4-dev.compare.beta.3` 。

一般情况下到达 `release` 阶段之后，开发版本的发布频率就可以大大降低了。
为了避免标签太多，在一个功能达 `release` 阶段之后，可以把对应的标签给删了。

### 前瞻版本

前瞻版本用来汇总开发中的功能，送给那些比较前卫的用户来体验。
但基于前瞻版本开发无法明确所依赖的功能，所以前瞻版本不用于开发。

当某个功能开发得比较成熟时，可以把这个功能的开发版本汇总到前瞻版本给大家用。
最好是开发阶段达到 `beta` 以上，才被认为是功能开发得比较成熟。

前瞻版本应该在名叫 `next` 的 Git 分支上发布。
将开发分支合并到 `next` 分支来汇总功能。

前瞻版本带 `next` 标签，版本号形如 `<x>.<y>.<z>` 。
其中：

- 版本号中 `<x>` 应该是偶数。
- 如果一个已被汇总功能的新的开发版本被汇总进来了，那递增一下 `<z>` ；
- 如果一个新功能被汇总到了前瞻版本，那么递增一下 `<y>` ，同时 `<z>` 重置为 `0`；
- 如果某次汇总包含一些破坏性更新，版本号可以从更高的 `<x>.0.0` 版本开始。
  比如在 `2.3.9` 的前瞻版本上汇总了一个叫 `deleteAllAndGiveEverythingUp` 的包含破坏性更新的功能，那这个前瞻版本可以叫 `4.0.0` 。

### 正式版本

与前瞻版本类似，正式版本用来汇总成熟的功能。
如果一个功能到达了 `release` 开发阶段，那就可以把这个功能合并到正式版本发布。

前瞻版本应该在 Git 仓库的主分支上发布，比如 `master` 分支。
将开发分支合并到主分支来汇总功能。

正式版本的标签是 `latest` ，形如 `<x>.<y>.<z>` 。
其中：

- 版本号中 `<x>` 应该是奇数。
- 如果一个已被汇总功能的新的开发版本被汇总进来了，那递增一下 `<z>` ；
- 如果一个新功能被汇总到了正式版本，那么递增一下 `<y>` ，同时 `<z>` 重置为 `0`。；
- 如果某次汇总包含一些破坏性更新，版本号可以从更高的 `<x>.0.0` 版本开始。
  比如在 `1.2.4` 的正式版本上汇总了一个叫 `deprecateAllApisAndKillThePackage` 的包含破坏性更新的功能，那这个正式版本可以叫 `3.0.0` 。

### 用于修复正式版本的功能

当正式版本中出现 bug 时，不再通过迭代开发版本来修复，而是把 bug 的修复当成一个功能来开发。
这种功能用于修复正式版本，由 `fix` 开头命名，比如 `fixTooManyUsefulfunction` 。

## 功能快速开发流程示例

以下较为全面地描述了一个功能快速开发的示例。
其中，“管理工具”表示能够实现功能快速开发的工具。
本工具也属于一个“管理工具”。

- 突然想开发一个功能：自动爆炸功能，英文名是 auto explode 。

- 开始开发，美滋滋。

  为了防止开发分支间的依赖关系过于复杂，任何功能都应在正式版本的基础上进行开发。
  所以第一步是在 `master` 分支上通过管理工具新建一个分支 `dev-autoExplode` （以下简称 A 分支），并且描述了一下这个分支所开发的功能，就是“人机分离十米自动爆炸”。

（不断展开下方的文本，可以浏览不同情况下的开发流程）

<details><summary>1) 单个包</summary>

- 在仓库中 `bomb` 包的 `3.2.4` 正式版本的基础上进行开发。
  开发的第一次提交是将版本号改为 `bomb@3.2.4-dev.autoExplode.alpha.0` 。

- 提交了几次，比如添加了爆炸函数。

- 感觉自己可以了，修改版本号——这次提交产生了一个开发版本 `bomb@3.2.4-dev.autoExplode.alpha.1` ，被管理工具自动发布。

<details><summary>2) 单分支</summary>

- 继续上述开发流程，开发版本不断递增。

- 开发到某一阶段，可能恰好这时正式版本 `bomb@3.3.0` 发布了。

  为了防止开发完成后 PR 出现代码合并问题，最好是在新的正式版本出现后立马切换到这个版本来继续开发。
  这样子即使这个版本和当前的代码有合并问题，也能在当下清楚地知道是新版的什么功能导致的。

  通过管理工具，基于 Git 的 `rebase` 命令把 `3.3.0` 版本引入 A 分支。
  引入完成后，管理工具将包版本号修正为 `bomb@3.3.0-dev.autoExplode.xxx.x` 。

- 不断地开发后，到达了 `bomb@3.3.0-dev.autoExplode.beta.0` 版本。

  推送到远程后，通过 GitHub PR 功能合并到 `next` 分支。
  管理工具验证 A 分支的 `bomb` 包确实已经达到了 `beta` 开发阶段及以上，允许合并分支。
  分支合并完后，管理工具为 `next` 分支上 `bomb` 包的次版本号递增一次，自动发布。

- 不断地开发后，到达了 `bomb@3.3.0-dev.autoExplode.release.0` 版本。

  推送到远程后，通过 GitHub PR 功能合并到 `master` 分支。
  管理工具验证 A 分支的 `bomb` 包确实已经达到了 `release` 开发阶段及以上，允许合并分支。
  分支合并完后，管理工具为 `master` 分支上 `bomb` 包的次版本号递增一次，自动发布。
  由于我们已经描述过功能，便可以用我们的描述来生成“Change Log”——“本次更新了：人机分离十米自动爆炸功能”。

  管理工具删除 npm 上的 `dev-autoExplode` 标签——这意味着这个功能基本开发完成，基本不再有大更新了。

</details><!-- 2) 单分支 -->

<details><summary>2) 多分支</summary>

- 又开发了几下，发现“侦测人机分离”的功能比较复杂，于是打算把这个功能单独列出来开发。
  于是通过管理工具在 `master` 的分支上新建分支 `dev-detectHuman` （以下简称 B 分支），功能描述为“侦测人机分离”。

- 在这个分支上的开发和上面“单分支”开发时的情况一模一样。
  如果这个分支又有需要单列出来的功能，那么就像 A 分支新建 B 分支一样再继续新建一个分支。

  ——多分支和单分支开发的差别主要不体现在新建的 B 这个分支上，而是体现在 A 对 B 分支的依赖关系上。

<details><summary>3) 无依赖关系</summary>

- 假如侦测人机分离功能比较简单，两秒钟就把 `release` 版本开发出来了，那立马就可以把 B 分支合并到正式版本上。
  之后 A 分支引入新鲜出炉的包含侦测人机分离功能的正式版本，就啥事也没有了，可以接着在 A 分支上开发自动爆炸功能。

</details><!-- 3) 无依赖关系 -->

<details><summary>3) 有依赖关系</summary>

- 假如侦测功能有点复杂，一时半会没法合并到正式版本上，那可以开发到一定程度之后让自动爆炸功能先用着，凑合一下。

  通过管理工具把 B 合并到 A 分支，并递增开发版本号，进行记录：A 分支依赖于 B 分支。

- 如果在 A 分支——也就是自动爆炸功能——开发完之前，B 分支——侦测人机分离功能——就开发完并合并到正式版本中，并且 A 分支引入了合并了 B 分支的正式版本，那么 A 和 B 分支间的依赖关系记录就可以被删除了。

- 如果侦测人机分离功能实在是有点复杂，以至于自动爆炸功能都达到 `beta` 开发阶段，侦测功能依然在 `alpha` 阶段，那么自动爆炸功能所在的 A 分支就受到了依赖关系的限制。

  由于依赖于一个未达到 `beta` 阶段及以上的 B 分支，就算 A 分支已经达到了 `release.9999` 版本，也不可以把 A 分支合并到前瞻版本。
  同样的，如果 B 分支低于 `release` 阶段，那么不论 A 分支是什么阶段，都不可以合并到正式版本中。

  这种依赖限制具有传递性。
  如果 B 分支又依赖 C 分支、C 分支又依赖 D 分支，那么 B、C、D 中只要有一个分支没有达到合并要求，A 分支就不可以合并。

</details><!-- 3) 有依赖关系 -->

-----

</details><!-- 2) 多分支 -->

-----

</details><!-- 1) 单个包 -->

<details> <summary>1) 多个包</summary>

- 以仓库中好多个包，比如 `bomb@3.2.4` 和 `detect@5.3.2` ，为基础进行开发。

  开发的第一次提交是将接下来要进行更改的包的版本改为 `-dev.<feature>.alpha.0` ——在此之后，任何一个包在有变更之前都要先改版本号为开发版本。
  这是为了保证管理工具能够清晰地辨别哪些包被修改了，而哪些没有。
  同时管理工具也应该具备寻找并修复那些被修改但忘记改版本号的包的能力。

<details><summary>2) 单分支</summary>

- 开发，仓库里各个包的开发版本不断递增。
  可能递增的速度不一样，这是正常的。

- 当某一个包的正式版更新后，来一次合并。

  这里和单个包没什么区别。

- 当分支的某些包到达足够合并的开发阶段后，可以对 `next` 或 `master` 分支进行一次 PR 。

  管理工具要能找到哪些包可以被合并，而哪些包不能合并。
  再只将那些可合并的包的代码的更改合并到 `next` 或 `master` 分支。

  根据技术上的实现难度，寻找哪些包可以合并而哪些不能，可以分为两个等级：
  1. 一刀切：

     看分支依赖链上的分支是否所有包都到达指定阶段：
     若有任意被依赖的分支并不是所有包都到达指定阶段，则本分支所有包都不合并；
     否则，再看分支内有没有未到达指定开发阶段的包：
     若有，则所有包都不合并；
     若无，则所有包都可以合并。
  2. 根据包间的依赖关系进行分析：

     建立每个包的依赖树：
     首先根据 `package.json` 找到这个包在同一分支内所依赖的处于开发状态的包；
     再根据依赖分支链中上一层分支里这个包是否是开发版本来断定这个包是否依赖于上一层分支的自己。
     就这么不断往下构建依赖树，直到找不到其他依赖为止就算构建完成。
     若树上有任意版本未达到开发状态，则这个包不能被合并。

</details><!-- 2) 单分支 -->

-----

</details><!-- 1) 多个包 -->

## 其他包发布流程

对于其他包，对应的发布流程各有不同。

### 直接在正式版本上开发

有些包由于代码简单，可以直接在正式版本上开发、迭代。
比如 `eslint-plugin-accurtype-style` 这个包。

这些包的开发通常也是在开发分支上进行的，但他们直接产生正式版本。
在开发分支上修改了包的内容后，直接修改包的版本为正式版本，再通过合并到主分支上来发布。

### 不包含前瞻版本的开发流程

有些包本身就比较具有实验性，或者此时还为到达稳定版本，可以在开发时跳过前瞻版本。

这种包的开发流程实际上就是主要包的流程除去前瞻版本。
其他包括开发版本、正式版本的发布等都相同。

## 工具需要实现的特性

需要实现的发布流程有如下几种：

### 发布开发版本流程

使用伪代码表示开发版本的发布流程：

```text

循环一 {
  对于仓库里的每个包 {
    如果 (
      公开性不为私有
      且 (
        package.json 是本次提交新建的
        或 (
          本次提交变更了版本号
          且 当前版本与npm不同
        )
      )
    ) 则 {
      标记为需要发布
    }
  }

  如果 (
    当前提交是分支第一个提交
    或 当前所有包的版本都与npm相同
  ) 则 {
    退出循环一
  }

  回退到上一个提交
}

对于每个被标记的包 {
  带着标签发布
}
```

### 前瞻版本和正式版本发布流程

使用 ASCII 流程图表示：

```text

            /----------------\
            |    开发过程    |
            |                V
            |        |----------------|
            \--------|                |
                     |  发布开发版本  |
          /----------|                |-----------\
          |          |----------------|           |
          V                                       V
 |------------------|                     |------------------|
 |  汇总到前瞻分支  |                     |  汇总到正式分支  |
 |------------------|                     |------------------|
          |                                       |
          V                                       V
   /------------\                              /------------\
  / 是否存在开发 \  是  |-------------|  是   / 是否存在开发 \
 / 阶段小于 beta / ---->|  PR 不通过  |<---- / 阶段小于      /
 \ 的包         /       |-------------|      \ release 的包 /
  \------------/                              \------------/
          |                                       |
       否 |                                    否 |
          |                                       |
          \---------------------------------------/
                              |
                              V
                     |----------------|
                     |  处理 PR 冲突  |
                     |----------------|
                              |
                              V
               |----------------------------|
               |  根据分支元数据递增版本号  |
               |----------------------------|
                              |
                              V
                  |----------------------|
                  |  测试、打标签、发布  |
                  |----------------------|
```
